# Feb 16
## 부분집합의 합
집합 {1,2,3}의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현

- i원소의 포함 여부를 결정 하면 i까지의 부분 집합의 합 s_i를 결정할 수 있음
- si_1이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음
- A[i] 원소를 부분 집합의 원소로 고려하는 재귀 함수(A는 서로 다른 자연수의 집합)
  
```python
# i-1원소까지 고려한 합 s, 찾으려는 합 t
f(i, N, s, t)
  if s == t
  elif i ==N
  elif s > t
  else
    subset[i] = 1
    f(i+1, N, s+A[i], t)
    subset[i] = 0
    f(i+1, N, s, t)
```

- 추가 고려 사항
고려한 구간의 합 S
S>T이면 중단
남은 구간의 합 RS
S + RS < T 남은 원소의 합을 다 더해도 찾는 값 T 미만인 경우 중단

### A[1,2,3]의 모든 원소를 사용한 순열
- 123, 132, 213, 231, 312, 321
- 총 6가지 경우
|---|---|---|
|---|---|---|
|1|2|3|
|---|3|2|
|2|1|3|
|---|3|1|
|3|2|1|
|---|1|2|

```python
f(i,N)
  if i == N
  else
    for j:i -> N-1
      P[i] <-> P[j]
      f(i+1, N)
      P[i] <-> P[j]
```

## 분할 정복 알고리즘
유래
- 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략
- 전력이 우세한 연합군을 공격하기 위해 나폴레옹은 연합군으 ㅣ중앙부로 쳐들어가 연합군을 둘로 나눔
- 둘로 나뉜 연합군을 한 부분씩 격파함
  
설계 전략
- 분할(Divide) : 해결한 문제를 여러 개의 작은 부분으로 나누다.
- 정복(Conquer) : 나눈 작은 문제를 각각 해결한다.
- 통합(Combine) : (필요하다면) 해결된 해답을 모은다.
  
### 분할 정복 예제
#### 거듭 제곱(Exponentiation)
- O(n)
```python
def Power(Base, Exponenet) :
  if Base == 0:
    return 1
  result = 1
  for  i in range(Exponent) :
    result *= Base
  return result
```

분할 정복 기반의 알고리즘
- O(log_2(n))
C^n
if n % 2 == 0 : C = C^(n/2)*C(n/2)
else : C = C^(n-1)/2 * C^(n-1)/2 * C
```python
def Power(Base, Exponent) :
  if Exponent == 0 or Base == 0:
    return 1
  if Exponent % 2 == 0:
    NewBase = Power(Base, Exponent/2)
    return NewBase * NewBase
  else:
    NewBase = Power(Base, (Exponenet-1)/2)
    return NewBase * Newbase * Base
```

#### 퀵 정렬
주어진 배열을 두 개로 분할하고, 각각을 정렬한다.
> 합병정렬과 동일?
다른점 1: 합병정렬은 그냥 두 부분으로 나누는 반면에, 퀵정렬은 분할할 때, 기준 아이템(pivot item) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
다른점 2: 각 부분 정렬이 끝난 후, 합병정렬은 "합병"이란 후처리 작업이 필요하나, 퀵정렬은 필요로 하지 않는다.

```python
def quickSort(a, begin, end) :
  if begin < end :
    p = partition(a, begin, end)
    quickSort(a, begin, p-1)
    quickSort(a, p+1, end)

def partition(a, begin, end):
  pivot = (begin+end) // 2
  L = begin
  R = end
  while L < R :
    while(L<R and A[L] < a[pivot]) : L += 1
    while(L<R and a[R] >= a[pivot]) : R -= 1
    if L < R :
      if L == pivot: pivot = R
      a[L], a[R] = a[R], a[L]
  a[pivot], a[R] = a[R], a[pivot]
  return R
```

##### 구현
{69, 10 30 2 16 8 31 22}
1. 원소 2를 피봇으로 선택하고 퀵 정렬 시작
  - L이 오른쪽으로 이동하면서 피봇보다 크거나 같은 원소를 찾고, R은 왼쪽으로 이동하면서 피봇보다 작은 원소를 찾는다.
  - L은 원소 69를 찾았지만, R은 피봇보다 작은 원소를 찾지 못한 채로 원소 69에서 L과 만나게 된다.
  - L과 R이 만났으므로, 원소 69를 피봇과 교환하여 피봇 원소 2의 위치를 확정한다.
2. 피봇 2의 왼쪽 부분 집합은 공집합이므로 퀵 정렬을 수행하지 않고, 오른쪽 부분 집합에 대해서 퀵 정렬 수행.
  - 오른쪽 부분 집합의 원소가 7개 이므로 가운데 있는 원소 16을 피봇으로 선택.
  - L이 찾은 30과 R이 찾은 8을 서로 교환한다.
  - 현태 위치에서 L과 R의 작업을 반복한다.
  - L은 원소 69를 찾았지만, R은 피봇보다 작은 원소를 찾지 못한 채로 원소 69에서 L과 만나게 된다.
  - L과 R이 만났으므로, 원소 69를 피봇과 교환하여 피봇 원소 16의 위치를 확정한다.
3. 피봇 16의 왼쪽 부분 집합에서 원소 10을 피봇으로 선택하여 퀵 정렬 수행.
  - L의 원소 10과 R의 원소 8을 교환하는데, L의 원소가 피봇이므로 피봇원소에 대한 자리교환이 발생한 것이므로 교환한 자리 피봇 원소 10의 위치로 확정한다.
4. 피봇 10의 확정된 위치에서의 왼쪽 부분 집합은 원소가 한개이므로 퀵 정렬을 수행하지 않고, 오른쪽 부분 집합은 공집합이므로 역시 퀵 정렬을 수행하지 않는다.
  - 이제 1단계의 피봇이었던 원소 16에 대한 오른쪽 부분 집합에 대해 퀵 정렬을 수행한다.
  오른쪽 부분집합의 원소가 4개이므로 두번째 원소 30을 피봇으로 선택한다.
  - L이 찾은 69와 R이 찾은 22를 서로 교환한다.

- 현재 위치에서 L과 R의 작업을 반복한다. L은 오른쪽으로 이동하면서 피봇보다 크거나 같은 원소인 30을 찾고, R은 왼쪽으로 이동하면서 피봇보다 작은 원소를 찾다가 못 찾고 원소 30에서 L과 만난다.
- L과 R이 만났으므로 피봇과 교환한다. 이 경우는 R의 원소가 피봇이므로 피봇에 대한 자리교환이 발생한 것이므로 교환한 자리를 피봇의 자리로 확정한다.
  
5. 피봇 30의 확정된 위치에서의 왼쪽 부분 집합의 원소가 한 개 이므로 퀵 정렬을 수행하지 않고, 오른족 부분 집합에 대해서 퀵 정렬 수행.
  - 오른쪽 부분 집합의 원소 2개 중에서 원소 31을 피봇으로 선택한다.
  - L은 오른쪽으로 이동하면서 원소 31을 찾고, R은 왼쪽으로 이동하면서 피봇 보다 작은 원소를 찾다가 못 찾은 채로 원소 31에서 L과 만난다. L과 R이 만났으므로 피봇과 교환하는데 R의 원소가 피봇이므로 결국 제자리가 확정된다.
- 피봇 31의 오른쪽 부분 집합의 원소가 한 개 이므로 퀵 정렬을 수행하지 않는다. 이것으로 전체 퀵 정렬 완성


##### 퀵 정렬 특성
퀵 정렬의 최악의 시간 복잡도는 O(n^2)로, 합병정렬(merge sort)에 비해 좋지 못하다.
그런데, 왜 "빠른" 정렬이라고 했을까?
이는 퀵정렬의 평균 복잡도는 nlogn 이기 때문이다.

|알고리즘|평균 수행시간|최악 수행시간|알고리즘 기법|비고|
|---|---|---|---|---|
|버블 정렬|O(n^2)|O(n^2)|비교와 교환|코딩이 가장 손쉬움|
|카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|n이 비교적 작을 때만 가능|
|선택 정렬|O(n^2)|O(n^2)|비교와 교환|교환의 회수가 버블, 삽입정렬보다 작음|
|퀵 정렬|O(n log n)|O(n^2)|분할 정복|최악의 경우 O(n^2) 이지만, 평균적으로는 가장 빠름|
|삽입 정렬|O(n^2)|O(n^2)|비교와 교환|n의 개수가 작을 때 효과적|
|병합 정렬|O(n log n)|O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식|
