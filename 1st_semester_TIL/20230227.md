# Feb 27
## Start
- SW 문제 해결
- 복잡도 분석
- 표준 입출력 방법
- 비트 연산
- 진수
- 실수

SW 문제 해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 이해한다.
효율적인 알고리즘의 필요성을 이해하고 알고리즘의 성능 측정 방법 중 하나인 시간복잡도에 대해 이해한다.
프로그램을 작성하기 위한 기본 중 표준 입출력 방법에 대해 이해한다.
비트 수준의 연산과 알고리즘에 대해 이해한다.
컴퓨터에서의 실수 표현 방법에 대해 이해한다.

프로그래밍 ... "잘하는 사람과 못하는 사람의 생산성 차이가 스무 배" ... [thinking in java]의 저자 브루스 에켈
프로그래밍하기 위한 제약 조건과 요구사항
- 프로그래밍 언어의 특성
- 프로그램이 동작할 HW와 OS에 관한 지식
- 라이브러리들의 유의 사항들
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드
- ...

### SW 문제 해결 역량이란 무엇인가?
- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 외선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 절재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
- 문제 해결 역량은 추상적인 기술이다.
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
  - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
- 문제 해결 역량을 향상시키기 위한 훈련이 필요하다.

문제해결 능력을 훈련하기 위해서는?
- 일부 새로운 언어, 프레임워크, 개발 방법론만을 배워나가는 것만으로 충분하지 않다.
  이들을 조합해 나가는 방법을 배워야 하지만 쉽지 않다.
- 경험을 통해서 나아지리라 막연히 짐작만 한다.
  그러나 경험에서는 문제 해결 능력을 개발 할 수 있는 상황이 주어지는 것이 아니며 또한 그런 상황에서 자기 개발을 하기는 쉽지 않다.
- 상황을 인위적으로 만들어 훈련해야 한다.
  즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시킬 수 있는 훈련이 필요하다.

문제 해결 과정
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

문제 해결 전략
- 직관과 체계적인 접근
체계적인 접근을 위한 질문들
- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화 할 수 있을까?
- 그림으로 그려 볼 수 있을까?
- 수식으로 표현할 수 있을까?
- 문제를 분해 할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?

## 복잡도 분석
### 알고리즘?
- (명) 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.
  주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.
- 예를 들어 1부터 100까지의 합을 구하는 문제를 생각해 보자

### 알고리즘의 효율
- 공간적 효율성과 시간적 효율성
  - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
  - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
  - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다. 복잡도가 높을수록 효율성은 저하된다.

알고리즘의 효율
- 시간적 복잡도 분석
  - 하드웨어 환경에 따라 처리시간이 달라진다.
    - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
    - 입출력 장비의 성능, 공유여부
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    - 프로그램 언어의 종류
    - 운영체제, 컴파일러의 종류
  - 이러한 환경적 차이로 인해 분석이 어렵다.

복잡도의 점근적 표기
- 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위한 점근적 표기 (Asymptotic Notation)를 사용한다.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
  - O(Big-Oh) - 표기
  - Ω(Big-Omega) - 표기
  - Θ(Big-Theta) - 표기

O(Big-Oh) - 표기
- O-표기는 복잡도의 점근적 상한을 나타낸다.
- 복잡도가 f(n) = 2n2-7n+4이라면, f(n)의 O- 표기는 O(n2)이다.
- 먼저 f(n)의 단순화된 표현은 n2이다.
- 단순화된 함수 n2에 임의의 상수 c를 곱한 cn2이 n이 증가함에 따라 f(n)의 상한이 된다.
  (단, c>0.)
> 단순히 "실행시간이 n<sup>2</sup>에 비례"하는 알고리즘이라고 말함.

복잡도 f(n)과 O-표기를 그래프로 나타내고 있다.
n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것을 보여 준다.
(즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것)

Ω(Big-Omega) - 표기
- 복잡도의 점근적 하한을 의미한다.
- f(n) = 2n2-7n+4의 Ω-표기는 Ω(n2)이다.
- f(n) = Ω(n2)은 "n이 증가함에 따라 2n2-7n이 cn2보다 작을 수 없다"라는 의미이다.
  이때 상수 c=1로 놓으면 된다.
- O-표기 때와 마찬가지로 Ω-표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
- **"최소한 이만한 시간은 걸린다"**

Θ(Big-Theta) - 표기
- O-표기와 Ω-표기가 같은 경우에 사용한다.
- f(n) = 2n<sup>2</sup> + 8n + 3 = O(n<sup>2</sup>)이므로, f(n) = Θ(n<sup>2</sup>)이다.
- **"f(n)은 n이 증가함에 따라 n<sup>2</sup>과 동일한 증가율을 가진다"** 라는 의미이다.

자주 사용하는 O-표기
|표기|의미|
|---|---|
|O(1)|상수 시간(Constant time)|
|O(logn)|로그(대수) 시간(Logarithmic time)|
|O(n)|선형 시간(Linear time)|
|O(nlogn)|로그 선형 시간(Log-Linear time)|
|O(n<sup>2</sup>)|제곱 시간(Quadratic time)|
|O(n<sup>3</sup>)|세제곱 시간(Cubic time)|
|O(2n)|지수 시간(Exponenetial time)|

왜 효율적인 알고리즘이 필요한가?
- 10억 개의 숫자를 정렬하는데 PC에서 O(n<sup>2</sup>) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬한다.
  |O(n<sup>2</sup>)|10<sup>3</sup>|10<sup>6</sup>|10<sup>9</sup>|
  |PC|<1second|2hours|300years|
  |SuperComputer|<1second|<1second|1week|
  |O(nlogn)|10<sup>3</sup>|10<sup>6</sup>|10<sup>9</sup>|
  |PC|<1second|<1second|5minutes|
  |SuperComputer|<1second|<1second|<1second|
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.
- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.


## 표준 입출력 방법
Python 3 표준입출력
- 입력
  - Raw 값의 입력 : input()
    - 받은 입력값을 문자열로 취급
  - Evaluated된 값 입력 : eval(input())
    - 받은 입력값을 평가된 데이터 형으로 취급
- 출력
  - print()
    - 표준 출력 함수, 출력값의 마지막에 개행 문자 ㄹ포함
  - print('text', end='')
    - 출력 시 마지막에 개행문자 제외할 시
  - print('%d' % number)
    - Formatting 된 출력

파일의 내용을 표준 입력으로 읽어오는 방법
- import sys
- sys.stding = open('a.txt', 'r')

### 비트 연산자
|연산자|연산자의 기능|
|---|---|
|&|비트단위로 AND 연산을 한다.|
|\||비트단위로 OR 연산을 한다.|
|^|비트단위로 XOR 연산을 한다.|
|~|단항 연산자로서 피연산자의 모든 비트를 반전시킨다.|
|<<|피연산자의 비트 열을 왼쪽으로 이동시킨다.|
|>>|피연산자의 비트 열을 오른쪽으로 이동시킨다.|

1<<n
- 2n의 값을 갖는다.
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- Power set (모든 부분집합)
  - 공집합과 자기 자신을 포함한 모든 부분집합
  - 각 원소가 포함되거나 포함되질 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.
i & (1<<j)
- 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.

### 엔디안(Endianness)
- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다.
- 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있다.
- 엔디안은 크게 두가지로 나뉨
  - 빅 엔디안(Big-Endian): 보통 큰 단위가 앞에 나옴. 네트워크
  - 리틀 엔디안(little-endian): 보통 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터
  |종류|0x1234의 표현|0x12345678의 표현|
  |---|---|---|
  |빅 엔디안|12 34|12 34 56 78|
  |리틀 엔디안|34 12|78 56 34 12|

엔디안 확인 코드
```python
import sys
print(sys.byteorder)
```

#### 예제3
```python
def ce(n): # change endian
  p = []
  for i in range(0,4):
    p.append((n>>(24-i*8)) &0xff)
  return p

x = 0x01020304
p = []
for i in range(0, 4):
  p.append((x>>(i*8)) & 0xff)

print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))
print = ce(x)
print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))
```

#### 예제4
```python
def ce1(n):
  return(n<<24 & 0xff000000 | (n << 8 & 0xff0000) | (n >> 8 & 0xff00) | (n >> 24 & 0xff))
```

#### 예제5
- 비트 연산자 ^를 두번 연산하면 처음 값을 반환한다.
```python
def Bbit_print(i):
  output = ""
  for j in range(7, -1, -1):
    output += "1" if i & (1 << j) else "0"
  print(output)

a = 0x86
key = 0xAA

print("a        ==> ", end = '')
Bbit_print(a)

print("a^=key   ==> ", end = '')
a ^= key
Bbit_print(a)

print("a^=key   ==> ", end = '')
a ^= key
Bbit_print(a)
```
